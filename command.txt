/*================= tips&trick ==============*/
. increase width of line 
set linesize 150; 

. increase column width
column colname format a24

/*================= set up ==============*/
1. set up scott account
info about account 
- hr/123123
- oe/123123

alter user scott account unlock
alter user scott identified by tiger;
conn scott/tiger

alter user scott identified by 123456 account unlock;

Note: run sys/123123 account in folder:
C:\Oracle\product\12.1.0\dbhome_1\BIN

sqlplus /nolog
connect sys /as sysdba

Note: chua test
-- list system privileges for the user or role
SELECT * FROM dba_sys_privs
WHERE grantee IN (&user_role, 'PUBLIC');
 

-- list object privileges for the user or role
SELECT grantee, owner||'.'||table_name object, privilege, grantable
FROM dba_tab_privs
WHERE grantee IN (&user_role)
ORDER BY grantee, owner||'.'||table_name, privilege;

-- Oracle 12c create new user:
ALTER SESSION SET "_ORACLE_SCRIPT"=true;
CREATE USER learning IDENTIFIED BY 123123;

grant CREATE SESSION, ALTER SESSION, CREATE DATABASE LINK, CREATE MATERIALIZED VIEW, 
	  CREATE PROCEDURE, CREATE PUBLIC SYNONYM, CREATE ROLE, CREATE SEQUENCE, 
	  CREATE SYNONYM, CREATE TABLE, CREATE TRIGGER, CREATE TYPE, CREATE VIEW, 
	  UNLIMITED TABLESPACE 
to learning;


/*===================================*/
0. Lenh tong hop:
. show current user:
show user
. 

1. Chon tat ca table cua 1 user 
select table_name
from all_tables 
where owner = 'scott';

select table_name 
from user_tables;


2. number(precision, scale)

/*=========================== CHAP 2 =======================*/
FORMAT:
1.
select distinct * from table;

2.
select 
	'THE ' ||region_name|| 'REGION IS ON PLANET' as "Planetery Location",
	region_id*100*5 as "Meteor prob",
	region_id
from regions;

3.
select 'this is text''s random''s usual' from dual;

4. missing NULL value:
employees has nullable department_id value. But department_id is foreigkey to table department. And department_id in department is not allowed to be NULL.
-> chap 7



Question:
1. 
select distinct department_id from employees;

2.
select distinct c.country_name 
from countries c, regions r
where c.region_id = r.region_id
and r.region_name = 'Europe';

Part:
3. 
select employee_id, job_id, start_date, end_date, (end_date - start_date)+1 "Days employed" 
from job_history;


4. Expression and column aliasing
select 'The '||region_name||' region is on planet earth' "Planetary Location",
	region_id*100/5 + 20/(10 - 5) "Meteor Shower Probability %",
	region_id "Region ID"
from regions;

5. Character and string concatenation operator
select employee_id as "Employee ID", first_name, last_name
from employees;

6. Literal and the DUAL table
select 'literal'||'processing using the REGIONS table'
from regions;

select 365.25*24*60*60 "Second in year" from dual;

select 'Plural''s have''s one [] QUOTE too many' "So many quotes" from dual;


Question:
7.
select employee_id, job_id, start_date, end_date, ((end_date-start_date)+1)/365.25 "Years employed"
from job_history;

8.
select 'The job ID for the '||job_title||'''s job is: '||job_id
as "Job Description"
from jobs;

9. 
select (22/7)*6000*6000 "Area"
from dual;


/*=========================== CHAP 3 =======================*/
rem ============ restricting and sorting data =============

1. Numeric-Based Conditions
select last_name, salary from employees where salary = 10000;
select last_name, salary from employees where salary = '10000';


2. Character-Based Conditions
(work) 		select last_name from employees where job_id='SA_REP';
(not work) 	select last_name from employees where job_id=SA_REP;

desc employees
JOB_ID		NOT NULL VARCHAR2(10)


3. Date-Based Conditions
select employee_id, job_id, last_name
from employees
where 'SA_REP'||'King' = job_id || last_name;

. So sanh 2 format date
select employee_id from job_history
where start_date = end_date;

. So sanh qua format date
select employee_id from job_history
where start_date = '01-JAN-2001';

select employee_id from job_history
where start_date = '01-JAN-01';

select employee_id from job_history
where start_date = '01-JANUARY-07';

select employee_id from job_history
where start_date = '01-JANUARY-2007';

select employee_id from job_history
where start_date = '01-JANUARY-2007';

If a literal occurs in an expression involving a DATE column, it is automatically converted into a date value using the default format mask. DD represents days, MON represents the first three letters of a month, and RR represents a Year 2000–compliant year (that is, if RR is between 50 and 99, then the Oracle server returns the previous century, else it returns the current century).
/*
insert into job_history(employee_id,start_date,end_date,job_id,department_id) 
values('999',01-JAN-1901,01-JAN-1999,'IT_PROG',110);
*/


4. 
select start_date, employee_id
from job_history
where start_date + 30 = '31-JAN-99';


5. Equality and Inequality
< 	> 	= 	!= 		
bewteen 	
like 	
>= 	<= 	<> 		
IS NULL		
IS NOT NULL


select last_name 
from employees 
where last_name < 'King';
(K+i+n+g = 75+105+110+103 = 393)


select last_name 
from employees
where salary between 3400 and 4000;

select last_name, salary 
from employees
where salary in (1000, 4000, 6000);

select last_name, salary 
from employees
where salary in (1000, 4000, 6000);


select first_name, last_name 
from employees
where last_name like 'King';

select first_name, last_name 
from employees
where last_name like 'K_ng';


select  *
from countries 
where country_name like 'I%a%';


select job_id 
from jobs
where job_id like 'SA\_' escape '\';
The ESCAPE identifier instructs the Oracle server to treat any character found
after the backslash character as a regular nonspecial symbol with no wildcard
meaning.

Question:
6. 
select department_name from departments where department_name like '%ing';


select first_name, last_name, commission_pct, hire_date
from employees
where first_name like 'J%'
and commission_pct > 0.1;

select first_name, last_name, commission_pct, hire_date
from employees
where first_name like 'B%'
or commission_pct > 0.35;


select last_name,salary,department_id,job_id,commission_pct
from employees
where last_name like '%a%' and salary > department_id * 100 and
commission_pct is not null
or
job_id = 'MK_MAN';



7. Sort the Rows Retrieved by a Query
. ORDER BY
select last_name, hire_date, salary
from employees
where job_id in ('SA_REP','MK_MAN')
order by last_name;


select last_name, salary, hire_date, hire_date-(salary/10) "Show"
from employees
where job_id in ('SA_REP','MK_MAN')
order by "Show";

//order by second column
select last_name, hire_date, salary
from employees
where job_id in ('SA_REP','MK_MAN')
order by 2;

//null value to the top, then sorting - nulls last: null value to the last of table
select last_name, salary, commission_pct
from employees
where job_id in ('SA_MAN','MK_MAN')
order by commission_pct desc nulls first;

select last_name from employees
where salary in (1000,4000,6000);


. Composite sorting
select job_id, last_name, salary, hire_date
from employees
where job_id in ('SA_REP','MK_MAN')
order by job_id desc, last_name, 3 desc;


. Ambersand substitution
DEFINE and VERIFY command

select employee_id, last_name, phone_number
from employees
where last_name = &LASTNAME
or employee_id = &EMPNO
;
-> enter value for last name: 'Smith'
-> enter value for empno: 0


. Double Ambersand substitution
select first_name, last_name
from employees
where last_name like '%&SEARCH%'
and first_name like '%&SEARCH%'
;
-> enter value for last name: K -> %K%
-> enter value for first name: S -> %S%

=> in case need to use same value appear in query several times
select first_name, last_name
from employees
where last_name like '%&&SEARCH%'
and first_name like '%&SEARCH%'
;

=> to undefine search value, use UNDEFINE command



. substituting column name 
select first_name, job_id, &&col
from employees
where job_id in ('MK_MAN', 'SA_MAN')
order by &col
;
--> input: salary


. undefine and verify 
select last_name, &&COLNAME
from employees
where department_id=30
order by &COLNAME
;
-> input: salary

select last_name, &COLNAME
from employees
where department_id=20
order by &COLNAME
;

undefine COLNAME
select last_name, &&COLNAME
from employees
where department_id=30
order by &COLNAME
;
-> input: salary

. command DEFINE
define emp_name=King
define;

select last_name, first_name
from employees
where last_name='&EMP_NAME'
;


. command VERIFY: The VERIFY command controls whether the substitution variable submitted is displayed onscreen so you can verify that the correct substitution has occurred.

VERIFY has on/off mode to let user input value

set verify off
select last_name, first_name
from employees
where last_name='&EMP_NAME2'
;
-> input: King

set verify on
select last_name, first_name
from employees
where last_name='&EMP_NAME2'
;
-> input: King
---------------------------------------------
SQL> set verify off
SQL> select last_name, first_name
  2  from employees
  3  where last_name='&EMP_NAME2'
  4  ;
Enter value for emp_name2: King

LAST_NAME                 FIRST_NAME
------------------------- --------------------
King                      Janette
King                      Steven


SQL> set verify on
SQL> select last_name, first_name
  2  from employees
  3  where last_name='&EMP_NAME2'
  4  ;
Enter value for emp_name2: King
old   3: where last_name='&EMP_NAME2'
new   3: where last_name='King'

LAST_NAME                 FIRST_NAME
------------------------- --------------------
King                      Janette
King                      Steven




/*=========================== CHAP 4 =======================*/
rem ============ single row function =============
- returns only one value per execution
- Three important components form the basis of defining a function
+ input parameters list
+ data type of its resultant value
+ detail of process

lower('SQL') = sql
upper('sql') = SQL
initcap('sql') = Sql

length('A short string') = 14

concat('SQL is',' easy to learn.') = SQL is easy to learn.

substr('http://www.domain.com',12,6) = domain

instr('http://www.domain.com','.',1,2) = 18

rpad('#PASSWORD#',11,'#') = #PASSWORD##
lpad('#PASSWORD#',11,'#') = ##PASSWORD#
trim('#' from '#PASSWORD#') = PASSWORD

replace('#PASSWORD#','WORD','PORT') = #PASSPORT#

round(42.39,1) = 42.4
trunc(42.39,1) = 42.3
mod(42,10) = 2

months_between('01-FEB-2008','01-JAN-2008') = 1
add_months('01-JAN-2008',1) = 01-FEB-2008

last_day('01-FEB-2008') = 29-FEB-2008
next_day('01-FEB-2008','Friday') = 08-FEB-2008

sysdate = 17-DEC-2007
round(sysdate,'month') = 01-JAN-2008
trunc(sysdate,'month') = 01-DEC-2007

-----------example--------
---single row
select region_id, region_name, length(region_name)
from regions
;

---multiple rows
select region_id, region_name, length(region_name), 
	substr(region_name, length(region_name), 1)
from regions
where length(region_name)>4
order by substr(region_name, length(region_name), 1)
;

----dual
select lower(100) from dual;
select lower(100+100) from dual;
select lower('The SUM '||'100+100'||' = 200') from dual;
select lower(SYSDATE) from dual;
select lower(SYSDATE+2) from dual;
select instr(3+0.14,'.') from dual; --> 2
select replace(10000-3,'9','85') from dual;
select replace('1#3#5#7#9#','#') from dual; --> 13579

command: 
ADD_MONTH, 
MONTH_BETWEEN, 
NEXT_DAY, 
LAST_DAY, 
ROUND(TO_DATE())



/*=========================== CHAP 5 =======================*/
rem === using conversion function and conditional expression ==== 

The concept of nesting functions is defined and a category of general functions aimed at simplifying interactions with NULL values is introduced. These include the NVL, NVL2, NULLIF, and COALESCE functions.

Query 1: select length(1234567890) from dual;
Query 2: select length(SYSDATE) from dual;
Query 3: select mod('11',2) from dual;
Query 4: select mod('11.123',2) from dual;

---need conversion
Query 5: select mod('11.123.456',2) from dual;
Query 6: select mod('$11',2) from dual;


=== nested function
Nested functions use the output from one function as the input to anotheranother. Functions always return exactly one result.

F1( param1.1, F2( param2.1, param2.2, F3( param3.1)), param1.3)

They are evaluated from the innermost to outermost levels.

select length(to_char(to_date('28/10/09', 'DD/MM/RR'),'fmMonth'))from dual
;
--> output: 7

select to_char(to_date('28/10/09', 'DD/MM/RR'),'fmMonth')from dual
;
--> output: October

=== general function 
General functions simplify working with columns that potentially contain null values. These functions accept input parameters of all data types. The services they offer are primarily relevant to null values.

=== NVL function 
The NVL function evaluates whether a column or expression of any data type is null or not. If the term is null, an alternative not null value is returned; otherwise, the initial term is returned.

select nvl(1234) from dual;
--> error
select nvl(null,1234) from dual;
--> 1234
select nvl(1234,0) from dual;
---> always the first number, if both not null: 1234


---example
select 
	last_name, 
	salary, 
	commission_pct, 
	(nvl(commission_pct,0) * salary + 1000) as "monthly commission"
from employees
where last_name like 'E%'
;

LAST_NAME                     SALARY COMMISSION_PCT monthly commission
------------------------- ---------- -------------- ------------------
Ernst                           6000                              1000
Errazuriz                      12000             .3               4600
Everett                         3900                              1000


select last_name, salary, commission_pct, (commission_pct * salary + 1000) as "monthly commission"
from employees
where last_name like 'E%'
;

LAST_NAME                     SALARY COMMISSION_PCT monthly commission
------------------------- ---------- -------------- ------------------
Ernst                           6000
Errazuriz                      12000             .3               4600
Everett                         3900


=== nvl2 function
The NVL2 function provides an enhancement to NVL but serves a very similar
purpose. It evaluates whether a column or expression of any data type is null or not. If the first term is not null, the second parameter is returned, else the third parameter is returned. Recall that the NVL function is different since it returns the original term if it is not null.

NVL2(original, ifnotnull, ifnull)
--> where original represents the term being tested. 
. Ifnotnull is returned if original is not null
. and ifnull is returned if original is null. 
. The data types of the ifnotnull and ifnull parameters must be compatible, and they cannot be of type LONG.

select nvl2(1234,1,'a string') from dual;
--> error
select nvl2(null,1234,5678) from dual;
--> 5678
select nvl2(substr('abc',2),'Not bc','No substring') from dual;
--> Not bc


---example
select last_name, salary, commission_pct,
nvl2(commission_pct, 'Commission Earner', 'Not a Commission Earner') 
as employsee_type
from employees
where last_name like 'G%'
;

LAST_NAME                     SALARY COMMISSION_PCT EMPLOYSEE_TYPE
------------------------- ---------- -------------- -----------------------
Gates                           2900                Not a Commission Earner
Gee                             2400                Not a Commission Earner
Geoni                           2800                Not a Commission Earner
Gietz                           8300                Not a Commission Earner
Grant                           2600                Not a Commission Earner
Grant                           7000            .15 Commission Earner
Greenberg                      12000                Not a Commission Earner
Greene                          9500            .15 Commission Earner


=== nullif function
The NULLIF function tests two terms for equality. If they are equal the function
returns a null, else it returns the first of the two terms tested.

select nullif(1234,1234) from dual;
--> null
select nullif(1234,123+1) from dual;
--> 1234
select nullif('24-JUL-2009','24-JUL-09') from dual;
--> 24-JUL-2009


=== coalesce function
The COALESCE function returns the first nonnull value from its parameter list. If
all its parameters are null, then null is returned.

COALESCE(expr1,expr2) = NVL(expr1,expr2)
COALESCE(expr1,expr2,expr3) = NVL(expr1,NVL(expr2,expr3))

select coalesce(null, null, null, 'a string') from dual;
--> a string
select coalesce(substr('abc',4),'Not bc','No substring') from dual;
--> not bc

---example
select 
	coalesce(state_province, postal_code, city), 
	postal_code, state_province, city
from locations
where country_id in ('UK', 'IT', 'JP')
;

COALESCE(STATE_PROVINCE,POSTAL POSTAL_CODE  STATE_PROVINCE            CITY
------------------------------ ------------ ------------------------- ------------------------------
00989                          00989                                  Roma
10934                          10934                                  Venice
Tokyo Prefecture               1689         Tokyo Prefecture          Tokyo
6823                           6823                                   Hiroshima
London                                                                London
Oxford                         OX9 9ZB      Oxford                    Oxford
Manchester                     09629850293  Manchester                Stretford


select 
	state_province, postal_code, city
from locations
where country_id in ('UK', 'IT', 'JP')
;
STATE_PROVINCE            POSTAL_CODE  CITY
------------------------- ------------ ------------------------------
                          00989        Roma
                          10934        Venice
Tokyo Prefecture          1689         Tokyo
                          6823         Hiroshima
                                       London
Oxford                    OX9 9ZB      Oxford
Manchester                09629850293  Stretford


=== conditional function
Conditional logic, also known as if-then-else logic, refers to choosing a path of
execution based on data values meeting certain conditions.

=== decode function 
The DECODE function implements if-then-else conditional logic by testing its first two terms for equality and returns the third if they are equal and optionally returns another term if they are not.

DECODE(expr1, comp1, iftrue1, [comp2, iftrue2...[ compN, iftrueN]], [iffalse]).

select decode(1234,123,'123 is a match') from dual;
--> null
select decode(1234,123,'123 is a match','No match') from dual;
--> No match
select decode('search','comp1','true1', 'comp2','true2', 'search','true3', substr('2search',2,6),'true4', 'false') from dual;
--> true3

---example 
select distinct 
	country_id, 
	decode(country_id, 'DR', 'Southern Hemisphere', 
			'AU', 'Southern Hemisphere', 'Northern Hemisphere')
	as hemisphere
from locations
order by hemisphere
;	

CO HEMISPHERE
-- -------------------
BR Northern Hemisphere
CA Northern Hemisphere
CH Northern Hemisphere
CN Northern Hemisphere
DE Northern Hemisphere
IN Northern Hemisphere
IT Northern Hemisphere
JP Northern Hemisphere
MX Northern Hemisphere
NL Northern Hemisphere
SG Northern Hemisphere
UK Northern Hemisphere
US Northern Hemisphere
AU Southern Hemisphere


=== CASE expression
CASE search_expr
	WHEN comparison_expr1 THEN iftrue1
	[WHEN comparison_expr2 THEN iftrue2
	…
		WHEN comparison_exprN THEN iftrueN
	ELSE iffalse]
END

select
	case substr(1234,1,3)
		when '134' then '1234 is a match'
		when '1235' then '1235 is a match'
		when concat('1','23') then concat('1','23')||' is a match'
		else 'no match'
	end
from dual;


select 
	last_name,
	hire_date,
	trunc(months_between(sysdate, hire_date)/12) as year,
	trunc(months_between(sysdate, hire_date)/60) as "year divide by 5",
case trunc(months_between(sysdate, hire_date)/60)
	when 0 then 'Intern'
	when 2 then 'Junior'
	when 4 then 'Intermediate'
	when 5 then 'Senior'
	else 'Furniture'
END as loyalty
from employees
where
	department_id in (10, 60)
;

LAST_NAME                 HIRE_DATE       YEAR year divide by 5 LOYALTY
------------------------- --------- ---------- ---------------- ------------
Whalen                    17-SEP-87         32                6 Furniture
Hunold                    03-JAN-90         30                6 Furniture
Ernst                     21-MAY-91         28                5 Senior
Austin                    25-JUN-97         22                4 Intermediate
Pataballa                 05-FEB-98         21                4 Intermediate
Lorentz                   07-FEB-99         20                4 Intermediate


select 
	last_name, 
	hire_date,
	trunc(months_between(sysdate,hire_date)/12) years,
	trunc(months_between(sysdate,hire_date)/60) "Years divided by 5",
case
	when trunc(months_between(sysdate,hire_date)/60) < 1 then 'Intern'
	when trunc(months_between(sysdate,hire_date)/60) < 2 then 'Junior'
	when trunc(months_between(sysdate,hire_date)/60) < 3 then 'Intermediate'
	when trunc(months_between(sysdate,hire_date)/60) < 4 then 'Senior'
	else 'Furniture'
end Loyalty
from employees
where department_id in (60,10)
;



/*=========================== CHAP 6 ==========================*/
rem === reporting aggregated data using the group function ==== 

Group functions are examined in two stages. First, their purpose and syntax is discussed. Second, a detailed analysis of the AVG, SUM, MIN, MAX, and COUNT functions is conducted.

F(g1, g2, g3,…, gn) = result1, result2, result2,…, resultn;

SELECT group_function(column or expression),…
FROM table [WHERE …] [ORDER BY…]

select 
	count(*), 
	department_id
from employees
group by department_id
order by department_id
;

  COUNT(*) DEPARTMENT_ID
---------- -------------
         1            10
         2            20
         6            30
         1            40
        45            50
         5            60
         1            70
        34            80
         2            90
         6           100
         2           110
         1           190
         1

=== Type and syntax of group function
The COUNT function counts the number of rows in a group. Its syntax is as follows:

COUNT({*|[DISTINCT|ALL] expr});

This syntax may be deconstructed into the following forms:
1. COUNT(*)
2. COUNT(DISTINCT expr)
3. COUNT(ALL expr)
4. COUNT(expr)


NUMBER, DATE, CHAR, or VARCHAR2. If expr is a null, it is ignored unless it is
managed using a general function like NVL, NVL2, or COALESCE.

The AVG function calculates the average value of a numeric column or
expression in a group. Its syntax is as follows:
AVG([DISTINCT|ALL] expr) ;
This syntax may be deconstructed into the following forms:
1. AVG(DISTINCT expr)
2. AVG(ALL expr)
3. AVG(expr)
FIGURE 6-1
Group functions
operating on 12
groups


When AVG(DISTINCT expr) is invoked, the distinct values of expr are summed
and divided by the number of unique occurrences of expr.

The SUM function returns the aggregated total of the nonnull numeric
expression values in a group. It has the following syntax:

SUM([DISTINCT|ALL] expr) ;

This syntax may be deconstructed into the following forms:
1. SUM(DISTINCT expr)
2. SUM(ALL expr)
3. SUM(expr)

SUM(DISTINCT expr) provides a total by adding all the unique values returned
after expr is evaluated for each row in the group. SUM(expr) and SUM(ALL expr)
provide a total by adding expr for each row in the group. Null values are ignored. The data type of expr is NUMBER.


The MAX and MIN functions return the maximum (largest) and minimum (smallest) expr value in a group. Their syntax is as follows:

MAX([DISTINCT|ALL] expr); MIN([DISTINCT|ALL] expr)

This syntax may be deconstructed into the following forms:
1. MAX(DISTINCT expr); MIN(DISTINCT expr)
2. MAX(ALL expr); MIN(ALL expr)
3. MAX(expr); MIN(expr);


The STDDEV and VARIANCE functions are two of many statistical group
functions Oracle provides. VARIANCE has the following syntax:

VARIANCE([DISTINCT|ALL] expr);

This syntax may be deconstructed into the following forms:
1. VARIANCE(DISTINCT expr)
2. VARIANCE(ALL expr)
3. VARIANCE(expr)


STDDEV has the following syntax:

STDDEV([DISTINCT|ALL] expr);

This syntax may be deconstructed into the following forms:
1. STDDEV(DISTINCT expr)
2. STDDEV(ALL expr)
3. STDDEV(expr)

=== examples 
select count(*) from employees;
--> 107 
select count(commission_pct) from employees;
--> 35
select count(distinct commission_pct) from employees;
--> 7
select count(hire_date), count(manager_id) from employees;
-->
COUNT(HIRE_DATE) COUNT(MANAGER_ID)
---------------- -----------------
             107               106
			 
select 
	count(hire_date), 
	count(manager_id), 
	count(commission_pct),
	count(distinct commission_pct) 	
from employees;


select sum(2) from employees
--> 2
select sum(salary) from employees;
--> 
SUM(SALARY)
-----------
     691400

select sum(distinct salary) from employees;
-->
SUM(DISTINCTSALARY)
-------------------
             397900

select sum(commission_pct) from employees;
-->
SUM(COMMISSION_PCT)
-------------------
                7.8

select min(commission_pct), max(commission_pct) from employees;
select min(start_date),max(end_date) from job_history;
select min(job_id),max(job_id) from employees;

select min(commission_pct), max(commission_pct) from employees;
select min(start_date),max(end_date) from job_history;
select min(job_id),max(job_id) from employees;

select 
	last_name, 
	first_name, 
	job_id,
	(sysdate-hire_date)/365.25 as "Years Worked"
from employees
where job_id = 'IT_PROG'
;


select 
	avg((sysdate-hire_date)/365.25)
		as "Avg worked years by IT staff"
from employees
where job_id = 'IT_PROG'
;
Avg worked years by IT staff
----------------------------
                  24.8065416

select 
	min(hire_date),
	min(salary),
	max(hire_date),
	max(salary)
from employees
where job_id = 'SA_REP'
;
MIN(HIRE_ MIN(SALARY) MAX(HIRE_ MAX(SALARY)
--------- ----------- --------- -----------
30-JAN-96        6100 21-APR-00       11500


select 
	last_name, 
	hire_date, 
	salary
from employees
where job_id = 'SA_REP'
and salary in (6100, 11500)
or hire_date in ('30-Jan-1996', '21-Apr-2000')
;
LAST_NAME                 HIRE_DATE     SALARY
------------------------- --------- ----------
King                      30-JAN-96      10000
Banda                     21-APR-00       6200
Ozer                      11-MAR-97      11500
Kumar                     21-APR-00       6100

=== nested group function
Group functions may only be nested two levels deep. Three formats using group functions are shown here:

G1(group_item) = result
G1(G2(group_item ) = result
G1(G2(G3(group_item))) is NOT allowed.

select 
	sum(commission_pct), 
	nvl(department_id, 0)
from employees
where nvl(department_id, 0) in (40, 80, 0)
group by department_id
;

SUM(COMMISSION_PCT) NVL(DEPARTMENT_ID,0)
------------------- --------------------
                .15                    0
                                      40
               7.65                   80
			   
--> explain by sql:
SQL> select
  2  sum(commission_pct)
  3  from employees
  4  where department_id = 40
  5  ;

SUM(COMMISSION_PCT)
-------------------


SQL> select
  2  sum(commission_pct)
  3  from employees
  4  where department_id = 80
  5  ;

SUM(COMMISSION_PCT)
-------------------
               7.65
			   
--> how to group this 2 results?
SQL> select
  2  sum(commission_pct),
  3  department_id
  4  from employees
  5  where department_id in (80, 40)
  6  group by department_id
  7  ;

SUM(COMMISSION_PCT) DEPARTMENT_ID
------------------- -------------
                               40
               7.65            80


=== group data using GROUP BY Clause
Group functions may be applied to these subsets or clusters of rows.

The SELECT statement is enhanced by the addition of the GROUP BY clause. This clause facilitates the creation of groups. It appears after the WHERE clause but before the ORDER BY clause, as follows:

SELECT column|expression|group_function(column|expression [alias]),…}
FROM table
[WHERE condition(s)]
[GROUP BY {col(s)|expr}]
[ORDER BY {col(s)|expr|numeric_pos} [ASC|DESC] [NULLS FIRST|LAST]];

select max(salary), count(*)
from employees
group by department_id
order by department_id
;
MAX(SALARY)   COUNT(*)
----------- ----------
       4400          1
      13000          2
      11000          6
       6500          1
       8200         45
       9000          5
      10000          1
      14000         34
      17000          2
      12000          6
      12000          2
      24000          1
       7000          1

select 
	max(salary),
	department_id
from employees
where department_id = 20
;
    SALARY DEPARTMENT_ID
---------- -------------
     13000            20
      6000            20


select 
	max(salary),
	department_id
from employees
where department_id = 20
group by department_id
;

MAX(SALARY) DEPARTMENT_ID
----------- -------------
      13000            20


select 
	max(salary), 
	count(*),
	department_id
from employees
group by department_id
order by department_id
;
MAX(SALARY)   COUNT(*) DEPARTMENT_ID
----------- ---------- -------------
       4400          1            10
      13000          2            20
      11000          6            30
       6500          1            40
       8200         45            50
       9000          5            60
      10000          1            70
      14000         34            80
      17000          2            90
      12000          6           100
      12000          2           110
----------- ---------- -------------
      24000          1           190
       7000          1

--->explain:
The grouping attribute in this example is the DEPARTMENT_ID column. The dataset, on which the group functions in the SELECT list must operate, is divided into 12 groups, one for each department. For each group (department), the maximum salary value and the number of rows are returned.

Any item in the SELECT list that is not a group function must be a grouping attribute of the GROUP BY clause.

select 
	to_char(end_date, 'YYYY') as "Year",
	count(*) as "Number of Employees"
from job_history
group by to_char(end_date, 'YYYY')
order by count(*) desc
;
Year Number of Employees
---- -------------------
1999                   4
1998                   3
1993                   2
1997                   1


=== grouping by multiple columns

select 
	department_id, 
	sum(commission_pct) 
from employees
where commission_pct is not null 
group by department_id
;

DEPARTMENT_ID SUM(COMMISSION_PCT)
------------- -------------------
                              .15
           80                7.65


select 
	department_id, 
	job_id, 
	sum(commission_pct) 
from employees
where commission_pct is not null 
group by department_id, job_id
;

DEPARTMENT_ID JOB_ID     SUM(COMMISSION_PCT)
------------- ---------- -------------------
           80 SA_REP                    6.15
           80 SA_MAN                     1.5
              SA_REP                     .15


=== include or exclude grouped rows using the HAVING Clause


select 
	department_id
from job_history
where department_id in (50,60,80,110)
;

DEPARTMENT_ID
-------------
           50
           50
           60
           80
           80
          110
          110


--> without WHERE clause:
select	
	department_id
from job_history
;

DEPARTMENT_ID
-------------
          110
           60
          110
           20
           50
           50
           90
           80
           80
           90

10 rows selected.

Suppose you want to know how many employees were previously employed in each of these departments. There are seven rows that can be manually grouped and counted. However, if there are a large number of rows, an aggregate function like COUNT may be used, as shown in the following query:

select 
	department_id, 
	count(*)
from job_history
where department_id in (50,60,80,110)
group by department_id
;

DEPARTMENT_ID   COUNT(*)
------------- ----------
           50          2
           60          1
           80          2
          110          2

Suppose you wanted to refine this list to include only those departments with more than one employee. The HAVING clause limits or restricts the group-level rows as required.

This query must perform the following steps:
1. Consider the entire row-level dataset.
2. Limit the dataset based on any WHERE clause conditions.
3. Segment the data into one or more groups using the grouping attributes specified in the GROUP BY clause.
4. Apply any aggregate functions to create a new group-level dataset. Each row may be regarded as an aggregation of its source row-level data based on the groups created.
5. Limit or restrict the group-level data with a HAVING clause condition. Only group-level results matching these conditions are returned.


=== the HAVING Clause
SELECT 
	column|expression|group_function(column|expression [alias]),…}
FROM table
[WHERE condition(s)]
[GROUP BY {col(s)|expr}]
[HAVING group_condition(s)]
[ORDER BY {col(s)|expr|numeric_pos} [ASC|DESC] [NULLS FIRST|LAST]];

An important difference between the HAVING clause and the other SELECT statement clauses is that it may only be specified if a GROUP BY clause is present.

select 
	department_id, 
	count(*)
from job_history
where department_id in (50,60,80,110)
group by department_id
having count(*)>1
;

DEPARTMENT_ID   COUNT(*)
------------- ----------
           50          2
           80          2
          110          2


select 
	max(salary), 
	sum(salary),
	count(*),
	department_id
from employees 
where department_id > 100
group by department_id
having count(*) > 1
order by department_id
;

MAX(SALARY) SUM(SALARY)   COUNT(*) DEPARTMENT_ID
----------- ----------- ---------- -------------
      12000       20300          2           110


/*=========================== CHAP 7 ==========================*/
rem === displaying data from multiple tables ==== 
■ Types of joins
■ Joining tables using SQL:1999 syntax
■ Qualifying ambiguous column names
■ The NATURAL JOIN clause
■ The natural JOIN USING clause
■ The natural JOIN ON clause
■ N-way joins and additional join conditions
■ Nonequijoins


 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COUNTRY_ID                                NOT NULL CHAR(2)
 COUNTRY_NAME                                       VARCHAR2(40)
 REGION_ID                                          NUMBER


 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 REGION_ID                                 NOT NULL NUMBER
 REGION_NAME                                        VARCHAR2(25)


=== NATURE JOIN, USING, JOIN
The NATURAL JOIN keywords instruct Oracle to identify columns with identical names between the source and target tables. Thereafter, a join is implicitly
performed between them.

1.
select 
	* 
from countries 
where country_id='CA';

CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
CA Canada                                            2

2.
select 
	region_name 
from regions 
where region_id='2';

REGION_NAME
-------------------------
Americas

Info:

select * from regions;
 REGION_ID REGION_NAME
---------- -------------------------
         2 Americas
         3 Asia
         4 Middle East and Africa
         1 Europe

select * from countries;
CO COUNTRY_NAME                              REGION_ID
-- ---------------------------------------- ----------
AR Argentina                                         2
AU Australia                                         3
BE Belgium                                           1
BR Brazil                                            2
CA Canada                                            2
CH Switzerland                                       1
CN China                                             3
DE Germany                                           1
DK Denmark                                           1
EG Egypt                                             4
FR France                                            1
HK HongKong                                          3
IL Israel                                            4
IN India                                             3
IT Italy                                             1
JP Japan                                             3
KW Kuwait                                            4
MX Mexico                                            2
NG Nigeria                                           4
NL Netherlands                                       1
SG Singapore                                         3
UK United Kingdom                                    1
US United States of America                          2
ZM Zambia                                            4
ZW Zimbabwe                                          4

25 rows selected.



3.
select
	*
from regions
natural join countries
;

 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         1 Europe                    FR France
         1 Europe                    UK United Kingdom
         1 Europe                    DK Denmark
         1 Europe                    BE Belgium
         1 Europe                    NL Netherlands
         1 Europe                    CH Switzerland
         1 Europe                    IT Italy
         1 Europe                    DE Germany
         2 Americas                  AR Argentina
         2 Americas                  BR Brazil
         2 Americas                  CA Canada

 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         2 Americas                  US United States of America
         2 Americas                  MX Mexico
         3 Asia                      IN India
         3 Asia                      CN China
         3 Asia                      JP Japan
         3 Asia                      SG Singapore
         3 Asia                      AU Australia
         3 Asia                      HK HongKong
         4 Middle East and Africa    ZM Zambia
         4 Middle East and Africa    NG Nigeria
         4 Middle East and Africa    KW Kuwait

 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         4 Middle East and Africa    ZW Zimbabwe
         4 Middle East and Africa    EG Egypt
         4 Middle East and Africa    IL Israel

25 rows selected.

4.
select
	region_name
from regions
natural join countries
where country_name = 'Canada'
;

REGION_NAME
-------------------------
Americas

5.
select
	*
from countries
natural join regions
;
 REGION_ID CO COUNTRY_NAME                             REGION_NAME
---------- -- ---------------------------------------- -------------------------
         1 FR France                                   Europe
         1 UK United Kingdom                           Europe
         1 DK Denmark                                  Europe
         1 BE Belgium                                  Europe
         1 NL Netherlands                              Europe
         1 CH Switzerland                              Europe
         1 IT Italy                                    Europe
         1 DE Germany                                  Europe
         2 AR Argentina                                Americas
         2 BR Brazil                                   Americas
         2 CA Canada                                   Americas

 REGION_ID CO COUNTRY_NAME                             REGION_NAME
---------- -- ---------------------------------------- -------------------------
         2 US United States of America                 Americas
         2 MX Mexico                                   Americas
         3 IN India                                    Asia
         3 CN China                                    Asia
         3 JP Japan                                    Asia
         3 SG Singapore                                Asia
         3 AU Australia                                Asia
         3 HK HongKong                                 Asia
         4 ZM Zambia                                   Middle East and Africa
         4 NG Nigeria                                  Middle East and Africa
         4 KW Kuwait                                   Middle East and Africa

 REGION_ID CO COUNTRY_NAME                             REGION_NAME
---------- -- ---------------------------------------- -------------------------
         4 ZW Zimbabwe                                 Middle East and Africa
         4 EG Egypt                                    Middle East and Africa
         4 IL Israel                                   Middle East and Africa

25 rows selected.

--> similar columns will be displayed first. Then goes source table, then target table comes later.


6.
select
	country_name
from countries
natural join regions
where region_name = 'Americas'
;
COUNTRY_NAME
----------------------------------------
Argentina
Brazil
Canada
United States of America
Mexico


7.
select
	*
from regions
join countries
using (region_id)
;
 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         1 Europe                    FR France
         1 Europe                    UK United Kingdom
         1 Europe                    DK Denmark
         1 Europe                    BE Belgium
         1 Europe                    NL Netherlands
         1 Europe                    CH Switzerland
         1 Europe                    IT Italy
         1 Europe                    DE Germany
         2 Americas                  AR Argentina
         2 Americas                  BR Brazil
         2 Americas                  CA Canada

 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         2 Americas                  US United States of America
         2 Americas                  MX Mexico
         3 Asia                      IN India
         3 Asia                      CN China
         3 Asia                      JP Japan
         3 Asia                      SG Singapore
         3 Asia                      AU Australia
         3 Asia                      HK HongKong
         4 Middle East and Africa    ZM Zambia
         4 Middle East and Africa    NG Nigeria
         4 Middle East and Africa    KW Kuwait

 REGION_ID REGION_NAME               CO COUNTRY_NAME
---------- ------------------------- -- ----------------------------------------
         4 Middle East and Africa    ZW Zimbabwe
         4 Middle East and Africa    EG Egypt
         4 Middle East and Africa    IL Israel

25 rows selected.

=== JOIN USING
When there are identical column names in the source and target tables you want to exclude as join columns, the JOIN…USING format may be used.

select
	region_name
from regions
join countries
using (region_id)
where country_name = 'Canada'
;
REGION_NAME
-------------------------
Americas


=== JOIN…ON format of the natural join, 
which allows join columns to be explicitly stated. This format does not depend on the columns in the source and target tables having identical names. 

This form is more general and is the most widely used natural join format.

select
	country_name
from countries
join regions
on (countries.region_id = regions.region_id)
where region_name = 'Americas'
;
COUNTRY_NAME
----------------------------------------
Argentina
Brazil
Canada
United States of America
Mexico


=== OUTER JOINS
Not all tables share a perfect relationship, where every record in the source table can be matched to at least one row in the target table. 

It is occasionally required that rows with nonmatching join column values also be retrieved by a query. This may seem to defeat the purpose of joins but has some practical benefits.


desc employees
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPLOYEE_ID                               NOT NULL NUMBER(6)
 FIRST_NAME                                         VARCHAR2(20)
 LAST_NAME                                 NOT NULL VARCHAR2(25)
 EMAIL                                     NOT NULL VARCHAR2(25)
 PHONE_NUMBER                                       VARCHAR2(20)
 HIRE_DATE                                 NOT NULL DATE
 JOB_ID                                    NOT NULL VARCHAR2(10)
 SALARY                                             NUMBER(8,2)
 COMMISSION_PCT                                     NUMBER(2,2)
 MANAGER_ID                                         NUMBER(6)
 DEPARTMENT_ID                                      NUMBER(4)


desc departments
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 DEPARTMENT_ID                             NOT NULL NUMBER(4)
 DEPARTMENT_NAME                           NOT NULL VARCHAR2(30)
 MANAGER_ID                                         NUMBER(6)
 LOCATION_ID                                        NUMBER(4)


Suppose the EMPLOYEES and DEPARTMENTS tables are joined with common DEPARTMENT_ID values. EMPLOYEES records with null DEPARTMENT_ID values are excluded along with values absent from the DEPARTMENTS table. An outer join fetches these rows.



=== CROSS JOINS
A cross join or Cartesian product derives its names from mathematics, where it is also referred to as a cross product between two sets or matrices. This join creates one row of output for every combination of source and target table rows.

example:
select count(*) from countries;
  COUNT(*)
----------
        25

select count(*) from regions;
  COUNT(*)
----------
         4

select count(*) from regions cross join countries;
  COUNT(*)
----------
       100


select	
	*
from regions
cross join countries
where country_id = 'CA'
;
 REGION_ID REGION_NAME               CO COUNTRY_NAME     REGION_ID
---------- ------------------------- -- --------------- ----------
         2 Americas                  CA Canada                   2
         3 Asia                      CA Canada                   2
         4 Middle East and Africa    CA Canada                   2
         1 Europe                    CA Canada                   2

select	
	*
from countries
where country_id = 'CA'
;
--> 100 rows

=== SYNTAX
1. NATURE JOIN
Query 1 performs a natural join by specifying the join as a condition in the WHERE clause.

select 
	regions.region_name, 
	countries.country_name
from regions, countries
where regions.region_id = countries.region_id
;

REGION_NAME               COUNTRY_NAME
------------------------- ----------------------------------------
Europe                    France
Europe                    United Kingdom
Europe                    Denmark
Europe                    Belgium
Europe                    Netherlands
Europe                    Switzerland
Europe                    Italy
Europe                    Germany
Americas                  Argentina
Americas                  Brazil
Americas                  Canada
------------------------- ----------------------------------------
Americas                  United States of America
Americas                  Mexico
Asia                      India
Asia                      China
Asia                      Japan
Asia                      Singapore
Asia                      Australia
Asia                      HongKong
Middle East and Africa    Zambia
Middle East and Africa    Nigeria
Middle East and Africa    Kuwait
------------------------- ----------------------------------------
Middle East and Africa    Zimbabwe
Middle East and Africa    Egypt
Middle East and Africa    Israel


Query 2 specifies the join between the source and target tables as a WHERE condition. There is a plus symbol enclosed in brackets (+) to the left of the equal sign that indicates to Oracle that a right outer join must be performed.

select 
	last_name, 
	department_name
from employees, departments
where employees.department_id (+) = departments.department_id
;

--ngoc's style
This query returns employees’ LAST_NAME and their matching DEPARTMENT_NAME values. 

In addition, the outer join retrieves DEPARTMENT_NAME from the rows with DEPARTMENT_ID values not currently assigned to any employee records.

select
	e.department_id,
	d.department_id,
	e.last_name, 
	d.department_name
from employees e, departments d
where e.department_id (+) = d.department_id
;

DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
           10            10 Whalen                    Administration
           20            20 Fay                       Marketing
           20            20 Hartstein                 Marketing
           30            30 Tobias                    Purchasing
           30            30 Colmenares                Purchasing
           30            30 Baida                     Purchasing
           30            30 Raphaely                  Purchasing
           30            30 Khoo                      Purchasing
           30            30 Himuro                    Purchasing
           40            40 Mavris                    Human Resources
           50            50 Feeney                    Shipping
------------- ------------- ------------------------- ------------------------------
           50            50 Fleaur                    Shipping
           50            50 Fripp                     Shipping
           50            50 Gates                     Shipping
           50            50 Gee                       Shipping
           50            50 Geoni                     Shipping
           50            50 Grant                     Shipping
           50            50 Jones                     Shipping
           50            50 Kaufling                  Shipping
           50            50 Ladwig                    Shipping
           50            50 Everett                   Shipping
           50            50 Dilly                     Shipping
DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
           50            50 Dellinger                 Shipping
           50            50 Davies                    Shipping
           50            50 Chung                     Shipping
           50            50 Cabrio                    Shipping
           50            50 Bull                      Shipping
           50            50 Bissot                    Shipping
           50            50 Bell                      Shipping
           50            50 Atkinson                  Shipping
           50            50 Landry                    Shipping
           50            50 Weiss                     Shipping
           50            50 Walsh                     Shipping
------------- ------------- ------------------------- ------------------------------
           50            50 Vollman                   Shipping
           50            50 Vargas                    Shipping
           50            50 Taylor                    Shipping
           50            50 Mallin                    Shipping
           50            50 Markle                    Shipping
           50            50 Marlow                    Shipping
           50            50 Matos                     Shipping
           50            50 McCain                    Shipping
           50            50 Mikkilineni               Shipping
           50            50 Mourgos                   Shipping
           50            50 Nayer                     Shipping

DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
           50            50 OConnell                  Shipping
           50            50 Olson                     Shipping
           50            50 Patel                     Shipping
           50            50 Perkins                   Shipping
           50            50 Philtanker                Shipping
           50            50 Rajs                      Shipping
           50            50 Rogers                    Shipping
           50            50 Sarchand                  Shipping
           50            50 Seo                       Shipping
           50            50 Stiles                    Shipping
           50            50 Sullivan                  Shipping
------------- ------------- ------------------------- ------------------------------
           60            60 Austin                    IT
           60            60 Pataballa                 IT
           60            60 Ernst                     IT
           60            60 Lorentz                   IT
           60            60 Hunold                    IT
           70            70 Baer                      Public Relations
           80            80 Abel                      Sales
           80            80 Ande                      Sales
           80            80 Banda                     Sales
           80            80 Bates                     Sales
           80            80 Bernstein                 Sales

DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
           80            80 Bloom                     Sales
           80            80 Cambrault                 Sales
           80            80 Cambrault                 Sales
           80            80 Doran                     Sales
           80            80 Errazuriz                 Sales
           80            80 Fox                       Sales
           80            80 Greene                    Sales
           80            80 Hall                      Sales
           80            80 Hutton                    Sales
           80            80 Johnson                   Sales
           80            80 King                      Sales
------------- ------------- ------------------------- ------------------------------
           80            80 Kumar                     Sales
           80            80 Lee                       Sales
           80            80 Livingston                Sales
           80            80 Marvins                   Sales
           80            80 McEwen                    Sales
           80            80 Olsen                     Sales
           80            80 Ozer                      Sales
           80            80 Partners                  Sales
           80            80 Russell                   Sales
           80            80 Sewall                    Sales
           80            80 Smith                     Sales

DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
           80            80 Smith                     Sales
           80            80 Sully                     Sales
           80            80 Taylor                    Sales
           80            80 Tucker                    Sales
           80            80 Tuvault                   Sales
           80            80 Vishney                   Sales
           80            80 Zlotkey                   Sales
           90            90 De Haan                   Executive
           90            90 Kochhar                   Executive
          100           100 Popp                      Finance
          100           100 Faviet                    Finance
------------- ------------- ------------------------- ------------------------------
          100           100 Chen                      Finance
          100           100 Greenberg                 Finance
          100           100 Urman                     Finance
          100           100 Sciarra                   Finance
          110           110 Gietz                     Accounting
          110           110 Higgins                   Accounting
                        120                           Treasury
                        130                           Corporate Tax
                        140                           Control And Credit
                        150                           Shareholder Services
                        160                           Benefits

DEPARTMENT_ID DEPARTMENT_ID LAST_NAME                 DEPARTMENT_NAME
------------- ------------- ------------------------- ------------------------------
                        170                           Manufacturing
                        180                           Construction
          190           190 King                      Contracting
                        200                           Operations
                        210                           IT Support
                        220                           NOC
                        230                           IT Helpdesk
                        240                           Government Sales
                        250                           Retail Sales
                        260                           Recruiting
                        270                           Payroll

121 rows selected.


Query 3 performs a Cartesian or cross join by excluding the join condition.
select * from regions,countries;
--> 100 rows


=== SQL 1999 SYNTAX
The general form of the SELECT statement using ANSI SQL:1999 syntax is as follows:
SELECT table1.column, table2.column
FROM table1
[NATURAL JOIN table2] |
[JOIN table2 USING (column_name)] |
[JOIN table2 ON (table1.column_name = table2.column_name)] |
[LEFT | RIGHT | FULL OUTER JOIN table2
ON (table1.column_name = table2.column_name)] |
[CROSS JOIN table2];

SELECT table1.column, table2.column
FROM table1, table2
[WHERE (table1.column_name = table2.column_name)] |
[WHERE (table1.column_name(+)= table2.column_name)] |
[WHERE (table1.column_name)= table2.column_name) (+)] ;


If no joins or fewer than N-1 joins are specified in the WHERE clause conditions, where N refers to the number of tables in the query, then a Cartesian or cross join is performed. 

If an adequate number of join conditions is specified, then the first optional conditional clause specifies a natural join, while the second two optional clauses specify the syntax for right and left outer joins.



=== Qualifying Ambiguous Column Name
select 
	emp.employee_id,
	department_id,
	emp.manager_id,
	departments.manager_id
from 
	employees emp
join departments
using (department_id)
where department_id > 80
;

EMPLOYEE_ID DEPARTMENT_ID MANAGER_ID MANAGER_ID
----------- ------------- ---------- ----------
        102            90        100        100
        101            90        100        100
        113           100        108        108
        112           100        108        108
        111           100        108        108
        110           100        108        108
        109           100        108        108
        108           100        101        108
        206           110        205        205
        205           110        101        205
        100           190

11 rows selected.


=== LEFT OUTER JOIN 
The format of the syntax for the LEFT OUTER JOIN clause is as follow:
SELECT table1.column, table2.column
FROM table1
LEFT OUTER JOIN table2
ON (table1.column = table2.column);

A left outer join performs an inner join of table1 and table2 based on the condition specified after the ON keyword. Any rows from the table on the left of the JOIN keyword excluded for not fulfilling the join condition are also returned.

example
select 
	e.employee_id, 
	e.department_id EMP_DEPT_ID,
	d.department_id DEPT_DEPT_ID, 
	d.department_name
from 
	departments d 
left outer join employees e
on (d.DEPARTMENT_ID = e.DEPARTMENT_ID)
where d.department_name like 'P%'
;

EMPLOYEE_ID EMP_DEPT_ID DEPT_DEPT_ID DEPARTMENT_NAME
----------- ----------- ------------ ------------------------------
                                 270 Payroll
        114          30           30 Purchasing
        115          30           30 Purchasing
        116          30           30 Purchasing
        117          30           30 Purchasing
        118          30           30 Purchasing
        119          30           30 Purchasing
        204          70           70 Public Relations

8 rows selected.


select 
	e.employee_id, 
	e.department_id EMP_DEPT_ID,
	d.department_id DEPT_DEPT_ID, 
	d.department_name
from 
	departments d 
join employees e
on (d.DEPARTMENT_ID = e.DEPARTMENT_ID)
where d.department_name like 'P%'
;

EMPLOYEE_ID EMP_DEPT_ID DEPT_DEPT_ID DEPARTMENT_NAME
----------- ----------- ------------ ------------------------------
        114          30           30 Purchasing
        115          30           30 Purchasing
        116          30           30 Purchasing
        117          30           30 Purchasing
        118          30           30 Purchasing
        119          30           30 Purchasing
        204          70           70 Public Relations

7 rows selected.


=== RIGHT OUTER JOIN
The format of the syntax for the RIGHT OUTER JOIN clause is as follows:
SELECT table1.column, table2.column
FROM table1
RIGHT OUTER JOIN table2
ON (table1.column = table2.column);

A right outer join performs an inner join of table1 and table2 based on the join condition specified after the ON keyword. Rows from the table to the right of the JOIN keyword, excluded by the join condition, are also returned.

example

select 
	e.last_name, 
	d.department_name 
from departments d
right outer join employees e
on (e.department_id = d.department_id)
where e.last_name like 'G%'
;

LAST_NAME                 DEPARTMENT_NAME
------------------------- ------------------------------
Grant                     Shipping
Geoni                     Shipping
Gee                       Shipping
Gates                     Shipping
Greene                    Sales
Greenberg                 Finance
Gietz                     Accounting
Grant

8 rows selected.


select 
	e.last_name, 
	d.department_name 
from departments d
join employees e
on (e.department_id = d.department_id)
where e.last_name like 'G%'
;

LAST_NAME                 DEPARTMENT_NAME
------------------------- ------------------------------
Grant                     Shipping
Gee                       Shipping
Geoni                     Shipping
Gates                     Shipping
Greene                    Sales
Greenberg                 Finance
Gietz                     Accounting

7 rows selected.


select 
	distinct jh.job_id as "job in Job History",
	e.job_id as "job in Employees"
from 
	job_history jh
right outer join
	employees e
on (jh.job_id = e.job_id)
order by jh.job_id
;

job in Job job in Emp
---------- ----------
AC_ACCOUNT AC_ACCOUNT
AC_MGR     AC_MGR
AD_ASST    AD_ASST
IT_PROG    IT_PROG
MK_REP     MK_REP
SA_MAN     SA_MAN
SA_REP     SA_REP
ST_CLERK   ST_CLERK
           AD_PRES
           AD_VP
           FI_ACCOUNT
---------- ----------
           FI_MGR
           HR_REP
           MK_MAN
           PR_REP
           PU_CLERK
           PU_MAN
           SH_CLERK
           ST_MAN

19 rows selected.


=== FULL OUTER JOIN
The format of the syntax for the FULL OUTER JOIN clause is as follows:
SELECT table1.column, table2.column
FROM table1
FULL OUTER JOIN table2
ON (table1.column = table2.column);

A full outer join returns the combined results of a left and right outer join. An inner join of table1 and table2 is performed before rows excluded by the join condition from both tables are merged into the results set.

select
	e.last_name,
	d.department_name
from 
	departments d
full outer join 
	employees e
on (e.department_id = d.department_id)
where e.department_id is null
;

LAST_NAME                 DEPARTMENT_NAME
------------------------- ------------------------------
Grant
                          NOC
                          Manufacturing
                          Government Sales
                          IT Support
                          Benefits
                          Shareholder Services
                          Retail Sales
                          Control And Credit
                          Recruiting
                          Operations
------------------------- ------------------------------
                          Treasury
                          Payroll
                          Corporate Tax
                          Construction
                          IT Helpdesk

16 rows selected.


=== CREATING CARTESIAN PRODUCT BY USING CROSS JOIN
The format of the syntax for the CROSS JOIN clause is as follows:
SELECT table1.column, table2.column
FROM table1
CROSS JOIN table2;

It is important to observe that no join condition is specified using the ON or USING keywords. A Cartesian product freely associates the rows from table1 with every row in table2.

example
select * from jobs cross join job_history;
select * from jobs j cross join job_history jh
where j.job_id='AD_PRES';

JOB_ID     JOB_TITLE  MIN_SALARY MAX_SALARY EMPLOYEE_ID START_DAT END_DATE  JOB_ID     DEPARTMENT_ID
---------- ---------- ---------- ---------- ----------- --------- --------- ---------- -------------
AD_PRES    President       20000      40000         101 21-SEP-89 27-OCT-93 AC_ACCOUNT           110
AD_PRES    President       20000      40000         102 13-JAN-93 24-JUL-98 IT_PROG               60
AD_PRES    President       20000      40000         101 28-OCT-93 15-MAR-97 AC_MGR               110
AD_PRES    President       20000      40000         201 17-FEB-96 19-DEC-99 MK_REP                20
AD_PRES    President       20000      40000         114 24-MAR-98 31-DEC-99 ST_CLERK              50
AD_PRES    President       20000      40000         122 01-JAN-99 31-DEC-99 ST_CLERK              50
AD_PRES    President       20000      40000         200 17-SEP-87 17-JUN-93 AD_ASST               90
AD_PRES    President       20000      40000         176 24-MAR-98 31-DEC-98 SA_REP                80
AD_PRES    President       20000      40000         176 01-JAN-99 31-DEC-99 SA_MAN                80
AD_PRES    President       20000      40000         200 01-JUL-94 31-DEC-98 AC_ACCOUNT            90

10 rows selected.


/*=========================== CHAP 8 ==========================*/
rem === using subqueries to solve problems ==== 

=== DEFINE SUBQUERY
A subquery is a query that is nested inside a SELECT, INSERT, UPDATE, or DELETE statement or inside another subquery.

The places in a query where a subquery may be used are as follows:
■ In the SELECT list used for column projection
■ In the FROM clause
■ In the WHERE clause
■ In the HAVING clause

A subquery is often referred to as an inner query, and the statement within which it occurs is then called the outer query.

A subquery can have any of the usual clauses for selection and projection. The
following are required clauses:
■ A SELECT list
■ A FROM clause
The following are optional clauses:
■ WHERE
■ GROUP BY
■ HAVING
The subquery (or subqueries) within a statement must be executed before the parent query that calls it, in order that the results of the subquery can be passed to the parent.


1. Use subquery result set for comparison purposes
select last_name from employees
where salary < (select avg(salary)from employees);

select 
	department_name 
from departments 
where department_id in
	(select 
		distinct(department_id) 
	from employees)
;

--> equal to:
select department_name from departments inner join employees
on employees.department_id = departments.department_id
group by department_name;

DEPARTMENT_NAME
------------------------------
Contracting
Executive
Administration
Marketing
Purchasing
Human Resources
Shipping
IT
Public Relations
Sales
Finance
Accounting

12 rows selected.


2. Star Transformation:
An extension of the use of subqueries as an alternative to a join is to enable the star transformation often needed in data warehouse applications. Consider a large table recording sales. 

Each sale is marked as being of a particular product to a particular buyer through a particular channel. These attributes are identified by codes, used as foreign keys to dimension tables with rows that describe each product, buyer, and channel. To identify all sales of books to buyers in Germany through Internet orders, one could run a query like this:

select … from sales s, products p, buyers b, channels c
where s.prod_code=p.prod_code
and s.buy_code=b.buy_code
and s.chan_code=c.chan_code
and p.product=’Books’
and b.country=’Germany’
and c.channel=’Internet’;

This query uses the WHERE clause to join the tables and then to filter the results. The following is an alternative query that will yield the same result:
select … from sales
where prod_code in (select prod_code from products where product=’Books’)
and buy_code in (select buy_code from buyers where country=’Germany’)
and chan_code in (select chan_code from channels where channel=’Internet);


3. Generate a Table from Which to SELECT:
Subqueries can also be used in the FROM clause, where they are sometimes referred to as inline views. Consider another problem based on the HR schema: 

employees are assigned to a department, and departments have a location. Each location is in a country. How can you find the average salary of staff in a country, even though they work for different departments? Like this:

select 
	avg(salary),
	country_id 
from
	(select 
		salary,
		department_id,
		location_id,
		country_id 
	from
		employees 
	natural join departments 
	natural join locations)
group by country_id
;

AVG(SALARY) CO
----------- --
       5640 US
       6000 CA
       8500 UK

The subquery constructs a table with every employee’s salary and the country in which his department is based. The parent query then addresses this table, averaging the SALARY and grouping by COUNTRY_ID.


3. Generate Value for Projection
The third place a subquery can go is in the SELECT list of a query. How can you identify the highest salary and the highest commission rate and thus what the maximum commission paid would be if the highest salaried employee also had the highest commission rate? Like this, with two subqueries:

select
	(select 
		max(salary) 
	from employees) *
	(select 
		max(commission_pct) 
	from employees)
	/ 100
from dual
;

(SELECTMAX(SALARY)FROMEMPLOYEES)*(SELECTMAX(COMMISSION_PCT)FROMEMPLOYEES)/100
-----------------------------------------------------------------------------
                                                                           96

In this usage, the SELECT list used to project columns is being populated with
the results of the subqueries. A subquery used in this manner must be scalar, or the parent query will fail with an error.


4. Generate Row to be passed to a DML Statement

insert into sales_hist select * from sales where date > sysdate-1;
update employees set salary = (select avg(salary) from employees);
delete from departments
where department_id not in (select department_id from employees);

The first example uses a subquery to identify a set of rows in one table that will be inserted into another. 

The second example uses a subquery to calculate the average salary of all employees and passes this value (a scalar quantity) to an update
statement. 

The third example uses a subquery to retrieve all DEPARTMENT_IDs that are in use and passes the list to a DELETE command, which will remove all departments that are not in use.

Note that it is not legal to use a subquery in the VALUES clause of an insert
statement; this is fine:
insert into dates select sysdate from dual;

But this is not:
insert into dates (date_col) values (select sysdate fom dual);



/*=========================== CHAP 9 ==========================*/
rem === Using the Set Operators ==== 

The set operators used in compound queries are as follows:
■ UNION Returns the combined rows from two queries, sorting them and
removing duplicates.
■ UNION ALL Returns the combined rows from two queries without sorting
or removing duplicates.
■ INTERSECT Returns only the rows that occur in both queries’ result sets,
sorting them and removing duplicates.
■ MINUS Returns only the rows in the first result set that do not appear in
the second result set, sorting them and removing duplicates.

These commands are equivalent to the standard operators used in mathematics
set theory, often depicted graphically as Venn diagrams.

Consider groupings of living creatures, classified as follows:
■ Creatures with two legs Humans, parrots, bats
■ Creatures that can fly Parrots, bats, bees
■ Creatures with fur Bears, bats

Each classification is known as a set, and each member of the set is an element. The union of the three sets is humans, parrots, bats, bees, and bears. 

This is all the elements in all the sets, without the duplications. The intersection of the sets is all elements that are common to all three sets, again removing the duplicates. In this simple example, the intersection has just one element: bats. 

The intersection of the two-legged set and the flying set has two elements: parrots and bats. The minus of the sets is the elements of one set without the elements of another, so the two-legged creatures set, minus the flying creatures set, minus the furry creatures set, results in a single element: humans.


/*=========================== CHAP 10 ==========================*/
rem === Manipulate Data ==== 

DDL commands, such as TRUNCATE, will fail if there is any DML command
active on the table. A transaction will block the DDL command until the DML
command is terminated with a COMMIT or a ROLLBACK.

■ INSERT
■ UPDATE
■ DELETE
■ TRUNCATE
In addition, we will discuss, for completeness:
■ MERGE
These are the commands that manipulate data.

The TRUNCATE command will empty the table, which is then repopulated from the
subquery. The end users can be let loose on this table, and it should be impossible for them to misinterpret the contents—a simple natural join with no COALESCE functions, which might be all an end user would do, might be
very misleading.

truncate table department_salaries;
insert into department_salaries (department,staff,salaries)
select
coalesce(department_name,'Unassigned'),
count(employee_id),
sum(coalesce(salary,0))
from employees e full outer join departments d
on e.department_id = d.department_id
group by department_name
order by department_name;




=== Update Rows in a Table

The UPDATE command changes column values in one or more existing rows in a single table. The basic syntax is the following:

UPDATE table SET column=value [,column=value…] [WHERE condition];

The more complex form of the command uses subqueries for one or more of the column values and for the WHERE condition.

---example
update
	employees
set salary = 10000
where employee_id = 206
;


update 
	employees
set salary = salary * 1.1
where department_id in
	(
		select department_id
		from departments
		where department_name like '%IT%'
	)
;























































































































































